<?xml version="1.0" encoding="UTF-8"?>

<!-- 
 * UniTime 3.0 (University Course Timetabling & Student Sectioning Application)
 * Copyright (C) 2007, UniTime.org
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 -->

<dbupdate>
	<dialect type="mysql">org.hibernate.dialect.MySQLInnoDBDialect</dialect>
	<dialect type="plsql">org.hibernate.dialect.OracleDialect</dialect>
	<update version="1" date="11-Jun-2007" comment="Package Renames, Column Renames">
		<sql>
			update %SCHEMA%.solver_info_def set implementation=replace(implementation,'edu.purdue.smas','org.unitime') where implementation like 'edu.purdue.smas%'
		</sql>
		<sql>
			update %SCHEMA%.solver_parameter_def set default_value=replace(default_value,'edu.purdue.smas','org.unitime') where default_value like 'edu.purdue.smas%'
		</sql>
		<sql>
			update %SCHEMA%.change_log set obj_type=replace(obj_type,'edu.purdue.smas','org.unitime') where obj_type like 'edu.purdue.smas%'
		</sql>
		<plsql onFail="done">
			alter table %SCHEMA%.tmtbl_mgr_to_roles rename column primary to is_primary
		</plsql>
		<mysql onFail="done">
			alter table %SCHEMA%.tmtbl_mgr_to_roles change column `primary` is_primary int(1) null
		</mysql>
	</update>
	<update version="2" date="13-Jul-2007" comment="Room group feature abbv">
		<plsql onFail="next">
			alter table %SCHEMA%.room_feature add abbv varchar2(20)
		</plsql>
		<plsql onFail="next">
			alter table %SCHEMA%.room_group add abbv varchar2(20)
		</plsql>
		<mysql onFail="next">
			alter table %SCHEMA%.room_feature add abbv varchar(20) binary null
		</mysql>
		<mysql onFail="next">
			alter table %SCHEMA%.room_group add abbv varchar(20) binary null
		</mysql>
	</update>
	<update version="3" date="13-Jul-2007" comment="On fly student sectioning">
		<sql onEqual="done" value="1">
			select count(*) from %SCHEMA%.solver_parameter_group g where g.name='OnFlySectioning'
		</sql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_group (uniqueid, name, description, ord) values 
			(%SCHEMA%.solver_parameter_group_seq.nextval, 'OnFlySectioning', 'On Fly Student Sectioning', -1)
		</plsql>
		<plsql>
			update %SCHEMA%.solver_parameter_group g set g.ord = ( select max(x.ord)+1 from %SCHEMA%.solver_parameter_group x )
			where g.name='OnFlySectioning'
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def (select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
			'OnFlySectioning.Enabled' as name, 'false' as default_value, 
			'Enable on fly sectioning (if enabled, students will be resectioned after each iteration)' as description,
			'boolean' as type, 0 as ord, 1 as visible, 
			uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='OnFlySectioning')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def (select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid,
			'OnFlySectioning.Recursive' as name, 'true' as default_value,
			'Recursively resection lectures affected by a student swap' as description,
			'boolean' as type, 1 as ord, 1 as visible,
			uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='OnFlySectioning')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def (select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid,
			'OnFlySectioning.ConfigAsWell' as name, 'false' as default_value,
			'Resection students between configurations as well' as description,
			'boolean' as type, 2 as ord, 1 as visible,
			uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='OnFlySectioning')
		</plsql>
		<mysql into="ID">
			select next_hi from %SCHEMA%.hibernate_unique_key			
		</mysql>
		<mysql into="ORD">
			select max(ord)+1 from %SCHEMA%.solver_parameter_group
		</mysql>
		<mysql>
			insert into %SCHEMA%.solver_parameter_group (uniqueid, name, description, ord) values
			(%ID%, 'OnFlySectioning', 'On Fly Student Sectioning', %ORD%)
		</mysql>
		<mysql>
			insert into %SCHEMA%.solver_parameter_def
			(uniqueid, name, default_value, description, type, ord, visible, solver_param_group_id) values
			(%ID%+1, 'OnFlySectioning.Enabled', 'false', 'Enable on fly sectioning (if enabled, students will be resectioned after each iteration)', 'boolean', 0, 1, %ID%),
			(%ID%+2, 'OnFlySectioning.Recursive', 'true', 'Recursively resection lectures affected by a student swap', 'boolean', 1, 1, %ID%),
			(%ID%+3, 'OnFlySectioning.ConfigAsWell', 'false', 'Resection students between configurations as well', 'boolean', 2, 1, %ID%) 
		</mysql>
		<mysql>
			update %SCHEMA%.hibernate_unique_key set next_hi=next_hi+4
		</mysql>
	</update>
	<update version="4" date="22-Aug-2007" comment="Timetable Grid Fix">
		<sql>
			update %SCHEMA%.user_data set value='-100' where name='TimetableGridTable.week' and value='-1'
		</sql>
	</update>
	<update version="5" date="04-Sep-2007" comment="Application config name size">
		<plsql onFail="done">
			alter table %SCHEMA%.application_config modify name varchar2(512)
		</plsql>
		<mysql onFail="done">
			alter table %SCHEMA%.application_config modify name varchar(512) binary not null
		</mysql>
	</update>
	<update version="6" date="15-Oct-2007" comment="Lastlike course demand permid">
		<mysql onFail="next">
			create index idx_ll_course_demand_permid on %SCHEMA%.lastlike_course_demand(course_perm_id)
		</mysql>
		<mysql onFail="next">
			alter table %SCHEMA%.course_offering modify perm_id varchar(20) binary null
		</mysql>
		<plsql onFail="next">
			create index %SCHEMA%.idx_ll_course_demand_permid on %SCHEMA%.lastlike_course_demand(course_perm_id)
		</plsql>
		<plsql onFail="next">
			alter table %SCHEMA%.course_offering drop constraint nn_course_offering_perm_id
		</plsql>
		<sql>
			update %SCHEMA%.lastlike_course_demand set course_perm_id = null where course_perm_id = '-1'
		</sql>
		<sql>
			update %SCHEMA%.course_offering set perm_id = null where perm_id = '-1'
		</sql>
	</update>
	<update version="7" date="16-Oct-2007" comment="IType Abbreviation">
		<sql onFail="next">
			update %SCHEMA%.itype_desc set abbv=smas_abbv where trim(abbv) is null or trim(abbv) = ''
		</sql>
		<sql onFail="next">
			alter table %SCHEMA%.itype_desc drop column smas_abbv
		</sql>
	</update>
	<update version="8" date="25-Oct-2007" comment="Distribution Pref add column">
		<plsql onFail="next">
			alter table %SCHEMA%.distribution_pref add uid_rolled_fwd_from number(20)
		</plsql>
		<mysql onFail="next">
			alter table %SCHEMA%.distribution_pref add uid_rolled_fwd_from decimal(20,0) null
		</mysql>
	</update>
	<update version="9" date="27-Nov-2007" comment="ItypeDesc parent">
		<plsql onFail="next">
			alter table %SCHEMA%.itype_desc add parent number(2)
		</plsql>
		<mysql onFail="next">
			alter table %SCHEMA%.itype_desc add parent int(2)
		</mysql>
		<plsql onFail="next">
			alter table %SCHEMA%.itype_desc add constraint fk_itype_parent foreign key (parent) references %SCHEMA%.itype_desc(itype)
		</plsql>
		<mysql onFail="next">
			alter table %SCHEMA%.itype_desc add constraint fk_itype_parent foreign key fk_itype_parent (parent) references %SCHEMA%.itype_desc(itype)
		</mysql>
		<plsql><![CDATA[
			update %SCHEMA%.itype_desc x set x.parent=(select max(i.itype) from %SCHEMA%.itype_desc i where i.itype<x.itype and i.basic=1) where x.basic=0
		]]></plsql>
		<mysql><![CDATA[
			create table %SCHEMA%.itype_dummy as (select i.itype, max(x.itype) as parent from %SCHEMA%.itype_desc i, %SCHEMA%.itype_desc x where i.basic=0 and x.basic=1 and x.itype<i.itype group by i.itype)
		]]></mysql>
		<mysql>
			update %SCHEMA%.itype_desc i set i.parent=(select x.parent from %SCHEMA%.itype_dummy x where x.itype=i.itype)
		</mysql>
		<mysql>
			drop table %SCHEMA%.itype_dummy
		</mysql>
	</update>
	<update version="10" date="29-Nov-2007" comment="Course offering cache number of last-like course demands">
		<mysql>
			alter table %SCHEMA%.course_offering add lastlike_demand bigint(10) not null default 0
		</mysql>
		<plsql>
			alter table %SCHEMA%.course_offering add lastlike_demand number(10) default 0
		</plsql>
		<plsql>
			alter table %SCHEMA%.course_offering add constraint nn_course_offering_ll_demand check (lastlike_demand is not null)
		</plsql>
		<sql>
			update %SCHEMA%.course_offering co set co.lastlike_demand = (
				select count(distinct cod.student_id) from %SCHEMA%.lastlike_course_demand cod
				where co.subject_area_id=cod.subject_area_id and co.course_nbr=cod.course_nbr
			) where co.perm_id is null
		</sql>
		<sql>
			update %SCHEMA%.course_offering co
			set co.lastlike_demand = (
				select count(distinct cod.student_id) from %SCHEMA%.lastlike_course_demand cod, %SCHEMA%.subject_area sa, %SCHEMA%.student s
				where co.perm_id=cod.course_perm_id and co.subject_area_id=sa.uniqueid and
				cod.student_id=s.uniqueid and s.session_id=sa.session_id
			) where co.perm_id is not null
		</sql>
	</update>
	<update version="11" date="07-Feb-2008" comment="Examination timetabling">
		<!-- Table DISTRIBUTION_TYPE, add column exam_pref (boolean) -->
		<plsql>alter table %SCHEMA%.distribution_type add exam_pref number(1) default 0</plsql>
		<mysql>alter table %SCHEMA%.distribution_type add exam_pref int(1) default 0</mysql>
		<!-- Added few exam distribution types (same period, same room, precedence) -->
		<plsql><![CDATA[
			insert into %SCHEMA%.distribution_type (uniqueid, reference, label, sequencing_required, req_id, allowed_pref, description, abbreviation, instructor_pref, exam_pref) values
			(%SCHEMA%.ref_table_seq.nextval, 'EX_SAME_PER', 'Same Period', 0, 36, 'P43210R', 'Exams are to be placed at the same period. <BR>When prohibited or (strongly) discouraged: exams are to be placed at different periods.', 'Same Per', 0, 1)
		]]></plsql>
		<plsql><![CDATA[
			insert into %SCHEMA%.distribution_type (uniqueid, reference, label, sequencing_required, req_id, allowed_pref, description, abbreviation, instructor_pref, exam_pref) values
			(%SCHEMA%.ref_table_seq.nextval, 'EX_SAME_ROOM', 'Same Room', 0, 37, 'P43210R', 'Exams are to be placed at the same room(s). <BR>When prohibited or (strongly) discouraged: exams are to be placed at different rooms.', 'Same Room', 0, 1)
		]]></plsql>
		 <plsql><![CDATA[
		 	insert into %SCHEMA%.distribution_type (uniqueid, reference, label, sequencing_required, req_id, allowed_pref, description, abbreviation, instructor_pref, exam_pref) values
		 	(%SCHEMA%.ref_table_seq.nextval, 'EX_PRECEDENCE', 'Precedence', 1, 38, 'P43210R', 'Exams are to be placed in the given order. <BR>When prohibited or (strongly) discouraged: exams are to be placed in the order reverse to the given one.', 'Precede', 0, 1)
		 ]]></plsql>
		<mysql into="ID">
			select next_hi from %SCHEMA%.hibernate_unique_key			
		</mysql>
		<mysql> <![CDATA[
			insert into %SCHEMA%.distribution_type (uniqueid, reference, label, sequencing_required, req_id, allowed_pref, description, abbreviation, instructor_pref, exam_pref) values 
			(%ID%, 'EX_SAME_PER', 'Same Period', 0, 36, 'P43210R', 'Exams are to be placed at the same period. <BR>When prohibited or (strongly) discouraged: exams are to be placed at different periods.', 'Same Per', 0, 1), 
			(%ID%+1, 'EX_SAME_ROOM', 'Same Room', 0, 37, 'P43210R', 'Exams are to be placed at the same room(s). <BR>When prohibited or (strongly) discouraged: exams are to be placed at different rooms.', 'Same Room', 0, 1), 
			(%ID%+2, 'EX_PRECEDENCE', 'Precedence', 1, 38, 'P43210R', 'Exams are to be placed in the given order. <BR>When prohibited or (strongly) discouraged: exams are to be placed in the order reverse to the given one.', 'Precede', 0, 1) 
		 ]]></mysql>
		<!-- Add exam start date to sessions -->	
		<plsql>alter table %SCHEMA%.sessions add exam_begin_date date</plsql>
		<plsql>update %SCHEMA%.sessions set exam_begin_date = session_begin_date_time+112</plsql>
		<mysql>alter table %SCHEMA%.sessions add exam_begin_date datetime</mysql>
		<mysql>update %SCHEMA%.sessions set exam_begin_date = adddate(session_begin_date_time,112)</mysql>	
		<sql>alter table %SCHEMA%.sessions add constraint nn_sessions_exam_begin_date check (exam_begin_date is not null)</sql>
		<!-- Create table exam_period -->
		<plsql>
			create table %SCHEMA%.exam_period (
				uniqueid number(20,0) constraint nn_exam_period_uniqueid not null,
				session_id number(20,0) constraint nn_exam_period_session not null,
				date_ofs number(10,0)  constraint nn_exam_period_date_ofs not null,
				start_slot number(10,0)  constraint nn_exam_period_start_slot not null,
				length number(10,0)  constraint nn_exam_period_length not null,
				pref_level_id number(20,0) constraint nn_exam_period_pref not null
			)
		</plsql>
		<plsql>alter table %SCHEMA%.exam_period add constraint pk_exam_period primary key (uniqueid)</plsql>
		<mysql>
			create table %SCHEMA%.exam_period (
				uniqueid decimal(20,0) primary key not null,
				session_id decimal(20,0) not null,
				date_ofs bigint(10)  not null,
				start_slot bigint(10)  not null,
				length bigint(10)  not null,
				pref_level_id decimal(20,0) not null
			)
		</mysql>
		<sql>
			alter table %SCHEMA%.exam_period add constraint fk_exam_period_session foreign key (session_id)
			references %SCHEMA%.sessions (uniqueid) on delete cascade
		</sql>
		<sql>
			alter table %SCHEMA%.exam_period add constraint fk_exam_period_pref foreign key (pref_level_id)
			references %SCHEMA%.preference_level (uniqueid) on delete cascade
		</sql>
		<!-- Rooms, and non-university locations - added columns exam_enable (boolean), exam_capacity (exam seating capacity, int), exam_pref (exam period preferences) -->
		<plsql>alter table %SCHEMA%.room add exam_enable number(1) default 0</plsql>
		<plsql>alter table %SCHEMA%.room add exam_capacity number(10) default 0</plsql>
		<plsql>alter table %SCHEMA%.room add exam_pref varchar2(1000)</plsql>
		<plsql>update %SCHEMA%.room set exam_capacity = capacity /2</plsql>
		<plsql>alter table %SCHEMA%.non_university_location add exam_enable number(1) default 0</plsql>
		<plsql>alter table %SCHEMA%.non_university_location add exam_capacity number(10) default 0</plsql>
		<plsql>alter table %SCHEMA%.non_university_location add exam_pref varchar2(1000)</plsql>
		<mysql>alter table %SCHEMA%.room add exam_enable int(1) default 0</mysql>
		<mysql>alter table %SCHEMA%.room add exam_capacity bigint(10) default 0</mysql>
		<mysql>alter table %SCHEMA%.room add exam_pref varchar(1000)</mysql>
		<mysql>update %SCHEMA%.room set exam_capacity = capacity /2</mysql>
		<mysql>alter table %SCHEMA%.non_university_location add exam_enable int(1) default 0</mysql>
		<mysql>alter table %SCHEMA%.non_university_location add exam_capacity bigint(10) default 0</mysql>
		<mysql>alter table %SCHEMA%.non_university_location add exam_pref varchar(1000)</mysql>
		<!-- Create exam manager role -->
		<plsql>insert into %SCHEMA%.roles (role_id, reference, abbv) values (%SCHEMA%.ROLE_SEQ.nextval, 'Exam Mgr', 'Examination Timetabling Manager')</plsql>
		<mysql>insert into %SCHEMA%.roles (role_id, reference, abbv) values (%ID%+3, 'Exam Mgr', 'Examination Timetabling Manager')</mysql>
		<mysql>update %SCHEMA%.hibernate_unique_key set next_hi=%ID%+4</mysql>
		<!-- Create table exam -->
		<plsql>
			create table %SCHEMA%.exam (
				uniqueid number(20,0) constraint nn_exam_uniqueid not null,
				session_id number(20,0) constraint nn_exam_session not null,
				name varchar2(100),
				note varchar2(1000),
				length number(10,0) constraint nn_exam_length not null,
				max_nbr_rooms number(10,0) default 1 constraint nn_exam_nbr_rooms not null,
				seating_type number(10,0) constraint nn_exam_seating not null,
				assigned_period number (20,0)
			)
		</plsql>
		<plsql>alter table %SCHEMA%.exam add constraint pk_exam primary key (uniqueid)</plsql>
		<mysql>
			create table %SCHEMA%.exam (
				uniqueid decimal(20,0) primary key not null,
				session_id decimal(20,0) not null,
				name varchar(100),
				note varchar(1000),
				length bigint(10) not null,
				max_nbr_rooms bigint(10) default 1 not null,
				seating_type bigint(10) not null,
				assigned_period decimal(20,0)
			)
		</mysql>
		<sql>
			alter table %SCHEMA%.exam add constraint fk_exam_session foreign key (session_id)
			references %SCHEMA%.sessions (uniqueid) on delete cascade
		</sql>
		<sql>
			alter table %SCHEMA%.exam add constraint fk_exam_period foreign key (assigned_period)
			references %SCHEMA%.exam_period (uniqueid) on delete cascade
		</sql>
		<!-- Create relation between exams and other objects (classes, configs, courses etc.) -->
		<plsql>
			create table %SCHEMA%.exam_owner (
				uniqueid number(20,0) constraint nn_exam_owner_unique_id not null,
				exam_id number(20,0) constraint nn_exam_owner_exam_id not null,
				owner_id number(20,0) constraint nn_exam_owner_owner_id not null,
				owner_type number(10,0) constraint nn_exam_owner_owner_type not null
			)
		</plsql>
		<plsql>alter table %SCHEMA%.exam_owner add constraint pk_exam_owner primary key (uniqueid)</plsql>
		<mysql>
			create table %SCHEMA%.exam_owner (
				uniqueid decimal(20,0) primary key not null,
				exam_id decimal(20,0) not null,
				owner_id decimal(20,0) not null,
				owner_type bigint(10) not null
			)
		</mysql>
		<sql>
			alter table %SCHEMA%.exam_owner add constraint fk_exam_owner_exam foreign key (exam_id)
			references %SCHEMA%.exam (uniqueid) on delete cascade
		</sql>
		<plsql>create index %SCHEMA%.idx_exam_owner_exam on %SCHEMA%.exam_owner(exam_id)</plsql>
		<plsql>create index %SCHEMA%.idx_exam_owner_owner on %SCHEMA%.exam_owner(owner_id, owner_type)</plsql>
		<mysql>create index idx_exam_owner_exam on %SCHEMA%.exam_owner(exam_id)</mysql>
		<mysql>create index idx_exam_owner_owner on %SCHEMA%.exam_owner(owner_id, owner_type)</mysql>
		<!-- Create table exam_room_assignment (relation exam - location) -->
		<plsql>
			create table %SCHEMA%.exam_room_assignment (
				exam_id number(20,0) constraint nn_exam_room_exam_id not null,
				location_id number(20,0) constraint nn_exam_room_location_id not null
			)
		</plsql>
		<plsql>alter table %SCHEMA%.exam_room_assignment add constraint pk_exam_room_assignment primary key (exam_id, location_id)</plsql>
		<mysql>
			create table %SCHEMA%.exam_room_assignment (
				exam_id decimal(20,0) not null,
				location_id decimal(20,0) not null,
				primary key (exam_id, location_id)
			)
		</mysql>
		<sql>
			alter table %SCHEMA%.exam_room_assignment add constraint fk_exam_room_exam foreign key (exam_id)
			references %SCHEMA%.exam (uniqueid) on delete cascade
		</sql>
		<!-- Added exam period preferences -->
		<plsql>
			create table %SCHEMA%.exam_period_pref (
				uniqueid number(20,0) constraint nn_exam_period_pref_uniqueid not null,
				owner_id number(20,0) constraint nn_exam_period_pref_owner not null,
				pref_level_id number(20,0) constraint nn_exam_period_pref_pref not null,
				period_id number(20,0) constraint nn_exam_period_pref_period not null
			)
		</plsql>
		<plsql>alter table %SCHEMA%.exam_period_pref add constraint pk_exam_period_pref primary key (uniqueid)</plsql>
		<mysql>
			create table %SCHEMA%.exam_period_pref (
				uniqueid decimal(20,0) primary key not null,
				owner_id decimal(20,0) not null,
				pref_level_id decimal(20,0) not null,
				period_id decimal(20,0) not null
			)
		</mysql>
		<sql>
			alter table %SCHEMA%.exam_period_pref add constraint fk_exam_period_pref_pref foreign key (pref_level_id)
			references %SCHEMA%.preference_level (uniqueid) on delete cascade
		</sql>
		<sql>
			alter table %SCHEMA%.exam_period_pref add constraint fk_exam_period_pref_period foreign key (period_id)
			references %SCHEMA%.exam_period (uniqueid) on delete cascade
		</sql>
		<!-- Instructor assignment -->
		<plsql>
			create table %SCHEMA%.exam_instructor (
				exam_id number(20,0) constraint nn_exam_instructor_exam not null,
				instructor_id number(20,0) constraint nn_exam_instructor_instructor not null
			)
		</plsql>
		<plsql>alter table %SCHEMA%.exam_instructor add constraint pk_exam_instructor primary key (exam_id, instructor_id)</plsql>
		<mysql>
			create table %SCHEMA%.exam_instructor (
				exam_id decimal(20,0) primary key not null,
				instructor_id decimal(20,0) not null
			)
		</mysql>
		<sql>
			alter table %SCHEMA%.exam_instructor add constraint fk_exam_instructor_exam foreign key (exam_id)
			references %SCHEMA%.exam (uniqueid) on delete cascade
		</sql>
		<sql>
			alter table %SCHEMA%.exam_instructor add constraint fk_exam_instructor_instructor foreign key (instructor_id)
			references %SCHEMA%.departmental_instructor (uniqueid) on delete cascade
		</sql>
	</update>
	<update version="12" date="08-Feb-2008" comment="Add course offering id to StudentClassEnrollment table">
		<plsql>alter table %SCHEMA%.student_class_enrl add course_offering_id number(20,0)</plsql>
		<mysql>alter table %SCHEMA%.student_class_enrl add course_offering_id decimal(20,0)</mysql>
		<sql>
			alter table %SCHEMA%.student_class_enrl add constraint fk_student_class_enrl_course foreign key (course_offering_id)
			references %SCHEMA%.course_offering (uniqueid) on delete cascade
		</sql>
	</update>
	<update version="13" date="11-Feb-2008" comment="Exams speedup">
		<plsql>alter table %SCHEMA%.exam_owner add course_id number(20,0)</plsql>
		<mysql>alter table %SCHEMA%.exam_owner add course_id decimal(20,0)</mysql>
		<sql>
			alter table %SCHEMA%.exam_owner add constraint fk_exam_owner_course foreign key (course_id)
			references course_offering (uniqueid) on delete cascade
		</sql>
		<sql>
			update %SCHEMA%.exam_owner o set o.course_id =
				(select co.uniqueid from %SCHEMA%.course_offering co where co.instr_offr_id=o.owner_id and co.is_control=1)
				where o.owner_type=0
		</sql>
		<sql>
			update %SCHEMA%.exam_owner set course_id = owner_id where owner_type=1
		</sql>
		<sql>
			update %SCHEMA%.exam_owner o set o.course_id =
			(select co.uniqueid from %SCHEMA%.instr_offering_config ioc, %SCHEMA%.course_offering co
			where ioc.uniqueid=o.owner_id and ioc.instr_offr_id=co.instr_offr_id and co.is_control=1)
			where o.owner_type=2
		</sql>
		<sql>
			update %SCHEMA%.exam_owner o set o.course_id =
			(select co.uniqueid from %SCHEMA%.instr_offering_config ioc, %SCHEMA%.course_offering co, %SCHEMA%.scheduling_subpart ss, %SCHEMA%.class_ c
			where c.uniqueid=o.owner_id and c.subpart_id=ss.uniqueid and
			ss.config_id=ioc.uniqueid and ioc.instr_offr_id=co.instr_offr_id and co.is_control=1)
			where o.owner_type=3
		</sql>
		<plsql>
			alter table %SCHEMA%.exam_owner add constraint nn_exam_owner_course check (course_id is not null)
		</plsql>
		<mysql>
			alter table %SCHEMA%.exam_owner modify course_id decimal(20,0) not null
		</mysql>
		<plsql>
			create index %SCHEMA%.idx_exam_owner_course on %SCHEMA%.exam_owner(course_id)
		</plsql>
		<mysql>
			create index idx_exam_owner_course on %SCHEMA%.exam_owner(course_id)
		</mysql>
	</update>
	<update version="14" date="22-Feb-2008" comment="Exam solver parameters">
		<plsql>alter table %SCHEMA%.solver_parameter_group add param_type number(10) default 0</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_group
				(uniqueid, name, description, condition, ord, param_type) values 
				(%SCHEMA%.solver_parameter_group_seq.nextval, 'ExamBasic', 'Basic Parameters', '', -1,1)
		</plsql>
		<plsql>
			update %SCHEMA%.solver_parameter_group g set g.ord = ( select max(x.ord)+1 from %SCHEMA%.solver_parameter_group x )
				where g.name='ExamBasic'
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid,
				'ExamBasic.Mode' as name, 
				'Initial' as default_value, 
				'Solver mode' as description, 
				'enum(Initial,MPP)' as type, 
				0 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamBasic')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid,
				'ExamBasic.WhenFinished' as name, 
				'No Action' as default_value, 
				'When finished' as description, 
				'enum(No Action,Save,Save and Unload)' as type, 
				1 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamBasic')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_group
				(uniqueid, name, description, condition, ord, param_type) values
				(%SCHEMA%.solver_parameter_group_seq.nextval, 'ExamWeights', 'Examination Weights', '', -1,1)
		</plsql>
		<plsql>
			update %SCHEMA%.solver_parameter_group g set g.ord = ( select max(x.ord)+1 from %SCHEMA%.solver_parameter_group x)
				where g.name='ExamWeights'
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid,
				'Exams.MaxRooms' as name, 
				'4' as default_value, 
				'Default number of room splits per exam' as description, 
				'integer' as type, 
				0 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamWeights')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Exams.IsDayBreakBackToBack' as name, 
				'false' as default_value, 
				'Consider back-to-back over day break' as description, 
				'boolean' as type, 
				1 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamWeights')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Exams.DirectConflictWeight' as name, 
				'1000.0' as default_value, 
				'Direct conflict weight' as description, 
				'double' as type, 
				2 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamWeights')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Exams.MoreThanTwoADayWeight' as name, 
				'100.0' as default_value, 
				'Three or more exams a day conflict weight' as description, 
				'double' as type, 
				3 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamWeights')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Exams.BackToBackConflictWeight' as name, 
				'10.0' as default_value, 
				'Back-to-back conflict weight' as description, 
				'double' as type, 
				4 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamWeights')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Exams.DistanceBackToBackConflictWeight' as name, 
				'25.0' as default_value, 
				'Distance back-to-back conflict weight' as description, 
				'double' as type, 
				5 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamWeights')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Exams.BackToBackDistance' as name, 
				'-1' as default_value, 
				'Back-to-back distance (-1 means disabled)' as description, 
				'double' as type, 
				6 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamWeights')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Exams.PeriodWeight' as name, 
				'1.0' as default_value, 
				'Period preference weight' as description, 
				'double' as type, 
				7 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamWeights')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Exams.RoomWeight' as name, 
				'1.0' as default_value, 
				'Room preference weight' as description, 
				'double' as type, 
				8 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamWeights')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Exams.DistributionWeight' as name, 
				'1.0' as default_value, 
				'Distribution preference weight' as description, 
				'double' as type, 
				9 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamWeights')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def 
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Exams.RoomSplitWeight' as name, 
				'10.0' as default_value, 
				'Room split weight' as description, 
				'double' as type, 
				10 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamWeights')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Exams.RoomSizeWeight' as name, 
				'0.001' as default_value, 
				'Excessive room size weight' as description, 
				'double' as type, 
				11 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamWeights')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Exams.NotOriginalRoomWeight' as name, 
				'1.0' as default_value, 
				'Not original room weight' as description, 
				'double' as type, 
				12 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamWeights')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Exams.RotationWeight' as name, 
				'0.001' as default_value, 
				'Exam rotation weight' as description, 
				'double' as type, 
				13 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamWeights')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_group 
			(uniqueid, name, description, condition, ord, param_type) values 
			(%SCHEMA%.solver_parameter_group_seq.nextval, 'Exam', 'General Parameters', '', -1,1)
		</plsql>
		<plsql>
			update %SCHEMA%.solver_parameter_group g set g.ord = ( select max(x.ord)+1 from %SCHEMA%.solver_parameter_group x )
				where g.name='Exam'
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Neighbour.Class' as name, 
				'net.sf.cpsolver.exam.heuristics.ExamNeighbourSelection' as default_value, 
				'Examination timetabling neighbour selection class' as description, 
				'text' as type, 
				0 as ord, 
				0 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='Exam')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Termination.TimeOut' as name, 
				'1800' as default_value, 
				'Maximal solver time (in sec)' as description, 
				'integer' as type, 
				1 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='Exam')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Exam.Algorithm' as name, 
				'Great Deluge' as default_value, 
				'Used heuristics' as description, 
				'enum(Great Deluge,Simulated Annealing)' as type, 
				2 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='Exam')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'HillClimber.MaxIdle' as name, 
				'25000' as default_value, 
				'Hill Climber: maximal idle iteration' as description, 
				'integer' as type, 
				3 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='Exam')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'Termination.StopWhenComplete' as name, 
				'false' as default_value, 
				'Stop when a complete solution if found' as description, 
				'boolean' as type, 
				4 as ord, 
				0 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='Exam')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'General.SaveBestUnassigned' as name, 
				'-1' as default_value, 
				'Save best when x unassigned' as description, 
				'integer' as type, 
				5 as ord, 
				0 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='Exam')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_group 
			(uniqueid, name, description, condition, ord, param_type) values 
			(%SCHEMA%.solver_parameter_group_seq.nextval, 'ExamGD', 'Great Deluge Parameters', '', -1,1)
		</plsql>
		<plsql>
			update %SCHEMA%.solver_parameter_group g set g.ord = ( select max(x.ord)+1 from %SCHEMA%.solver_parameter_group x )
			where g.name='ExamGD'
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'GreatDeluge.CoolRate' as name, 
				'0.99999995' as default_value, 
				'Cooling rate' as description, 
				'double' as type, 
				0 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamGD')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'GreatDeluge.UpperBoundRate' as name, 
				'1.05' as default_value, 
				'Upper bound rate' as description, 
				'double' as type, 
				1 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamGD')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'GreatDeluge.LowerBoundRate' as name, 
				'0.95' as default_value, 
				'Lower bound rate' as description, 
				'double' as type, 
				2 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamGD')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_group 
			(uniqueid, name, description, condition, ord, param_type) values 
			(%SCHEMA%.solver_parameter_group_seq.nextval, 'ExamSA', 'Simulated Annealing Parameters', '', -1,1)
		</plsql>
		<plsql>
			update %SCHEMA%.solver_parameter_group g set g.ord = ( select max(x.ord)+1 from %SCHEMA%.solver_parameter_group x )
			where g.name='ExamSA'
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'SimulatedAnnealing.InitialTemperature' as name, 
				'1.5' as default_value, 
				'Initial temperature' as description, 
				'double' as type, 
				0 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamSA')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'SimulatedAnnealing.CoolingRate' as name, 
				'0.95' as default_value, 
				'Cooling rate' as description, 
				'double' as type, 
				1 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamSA')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'SimulatedAnnealing.TemperatureLength' as name, 
				'25000' as default_value, 
				'Temperature length' as description, 
				'integer' as type, 
				2 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamSA')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_parameter_def
			(select %SCHEMA%.solver_parameter_def_seq.nextval as uniqueid, 
				'SimulatedAnnealing.ReheatLengthCoef' as name, 
				'5' as default_value, 
				'Reheat length coefficient' as description, 
				'double' as type, 
				3 as ord, 
				1 as visible, 
				uniqueid as solver_param_group_id from %SCHEMA%.solver_parameter_group where name='ExamSA')
		</plsql>
		<plsql>
			insert into %SCHEMA%.solver_predef_setting (uniqueid, name, description, appearance)
			values(%SCHEMA%.solver_predef_setting_seq.nextval, 'Exam.Default', 'Default', 2)
		</plsql>
		<mysql>alter table %SCHEMA%.solver_parameter_group add param_type bigint(10) default 0</mysql>
		<mysql into="ID">
			select next_hi from %SCHEMA%.hibernate_unique_key			
		</mysql>
		<mysql into="ORD">
			select max(ord)+1 from %SCHEMA%.solver_parameter_group
		</mysql>
		<mysql>
			insert into %SCHEMA%.solver_parameter_group (uniqueid, name, description, ord, param_type) values
			(%ID%, 'ExamBasic', 'Basic Parameters', %ORD%, 1),
			(%ID%+1, 'ExamWeights', 'Examination Weights', %ORD%+1, 1),
			(%ID%+2, 'Exam', 'General Parameters', %ORD%+2, 1),
			(%ID%+3, 'ExamGD', 'Great Deluge Parameters', %ORD%+3, 1),
			(%ID%+4, 'ExamSA', 'Simulated Annealing Parameters', %ORD%+4, 1)
		</mysql>
		<mysql>
			insert into %SCHEMA%.solver_parameter_def
			(uniqueid, name, default_value, description, type, ord, visible, solver_param_group_id) values
			(%ID%+5, 'ExamBasic.Mode', 'Initial', 'Solver mode', 'enum(Initial,MPP)', 0, 1, %ID%),
			(%ID%+6, 'ExamBasic.WhenFinished', 'No Action', 'When finished', 'enum(No Action,Save,Save and Unload)', 1, 1, %ID%),
			(%ID%+7, 'Exams.MaxRooms', '4', 'Default number of room splits per exam', 'integer', 0, 1, %ID%+1),
			(%ID%+8, 'Exams.IsDayBreakBackToBack', 'false', 'Consider back-to-back over day break', 'boolean', 1, 1, %ID%+1),
			(%ID%+9, 'Exams.DirectConflictWeight', '1000.0', 'Direct conflict weight', 'double', 2, 1, %ID%+1),
			(%ID%+10, 'Exams.MoreThanTwoADayWeight', '100.0', 'Three or more exams a day conflict weight', 'double', 3, 1, %ID%+1),
			(%ID%+11, 'Exams.BackToBackConflictWeight', '10.0', 'Back-to-back conflict weight', 'double', 4, 1, %ID%+1),
			(%ID%+12, 'Exams.DistanceBackToBackConflictWeight', '25.0', 'Distance back-to-back conflict weight', 'double', 5, 1, %ID%+1),
			(%ID%+13, 'Exams.BackToBackDistance', '-1', 'Back-to-back distance (-1 means disabled)', 'double', 6, 1, %ID%+1),
			(%ID%+14, 'Exams.PeriodWeight', '1.0', 'Period preference weight', 'double', 7, 1, %ID%+1),
			(%ID%+15, 'Exams.RoomWeight', '1.0', 'Room preference weight', 'double', 8, 1, %ID%+1),
			(%ID%+16, 'Exams.DistributionWeight', '1.0', 'Distribution preference weight', 'double', 9, 1, %ID%+1),
			(%ID%+17, 'Exams.RoomSplitWeight', '10.0', 'Room split weight', 'double', 10, 1, %ID%+1),
			(%ID%+18, 'Exams.RoomSizeWeight', '0.001', 'Excessive room size weight', 'double', 11, 1, %ID%+1),
			(%ID%+19, 'Exams.NotOriginalRoomWeight', '1.0', 'Not original room weight', 'double', 12, 1, %ID%+1),
			(%ID%+20, 'Exams.RotationWeight', '0.001', 'Exam rotation weight', 'double', 13, 1, %ID%+1),
			(%ID%+21, 'Neighbour.Class', 'net.sf.cpsolver.exam.heuristics.ExamNeighbourSelection', 'Examination timetabling neighbour selection class', 'text', 0, 0, %ID%+2),
			(%ID%+22, 'Termination.TimeOut', '1800', 'Maximal solver time (in sec)', 'integer', 1, 1, %ID%+2),
			(%ID%+23, 'Exam.Algorithm', 'Great Deluge', 'Used heuristics', 'enum(Great Deluge,Simulated Annealing)', 2, 1, %ID%+2),
			(%ID%+24, 'HillClimber.MaxIdle', '25000', 'Hill Climber: maximal idle iteration', 'integer', 3, 1, %ID%+2),
			(%ID%+25, 'Termination.StopWhenComplete', 'false', 'Stop when a complete solution if found', 'boolean', 4, 0, %ID%+2),
			(%ID%+26, 'General.SaveBestUnassigned', '-1', 'Save best when x unassigned', 'integer', 5, 0, %ID%+2),
			(%ID%+27, 'GreatDeluge.CoolRate', '0.99999995', 'Cooling rate', 'double', 0, 1, %ID%+3),
			(%ID%+28, 'GreatDeluge.UpperBoundRate', '1.05', 'Upper bound rate', 'double', 1, 1, %ID%+3),
			(%ID%+29, 'GreatDeluge.LowerBoundRate', '0.95', 'Lower bound rate', 'double', 2, 1, %ID%+3),
			(%ID%+30, 'SimulatedAnnealing.InitialTemperature', '1.5', 'Initial temperature', 'double', 0, 1, %ID%+4),
			(%ID%+31, 'SimulatedAnnealing.CoolingRate', '0.95', 'Cooling rate', 'double', 1, 1, %ID%+4),
			(%ID%+32, 'SimulatedAnnealing.TemperatureLength', '25000', 'Temperature length', 'integer', 2, 1, %ID%+4),
			(%ID%+33, 'SimulatedAnnealing.ReheatLengthCoef', '5', 'Reheat length coefficient', 'double', 3, 1, %ID%+4)
		</mysql>
		<mysql>
			insert into %SCHEMA%.solver_predef_setting (uniqueid, name, description, appearance) values 
			(%ID%+34, 'Exam.Default', 'Default', 2)
		</mysql>
		<mysql>
			update %SCHEMA%.hibernate_unique_key set next_hi=next_hi+35
		</mysql>
	</update>
	<update version="15" date="25-Feb-2008" comment="Exam conflicts">
		<plsql>
			create table %SCHEMA%.xconflict (
				uniqueid number(20,0) constraint nn_xconflict_uniqueid not null,
				conflict_type number(10,0) constraint nn_xconflict_type not null,
				distance float)
		</plsql>
		<plsql>
			alter table %SCHEMA%.xconflict
			add constraint pk_xconflict primary key (uniqueid)
		</plsql>
		<mysql>
			create table %SCHEMA%.xconflict (
				uniqueid decimal(20,0) not null primary key,
				conflict_type decimal(10,0) not null,
				distance double)
		</mysql>
		<plsql>
			create table %SCHEMA%.xconflict_exam (
				conflict_id number(20,0) constraint nn_xconflict_ex_conf not null,
				exam_id number(20,0) constraint nn_xconflict_ex_exam not null)
		</plsql>
		<plsql>
			alter table %SCHEMA%.xconflict_exam
  			add constraint pk_xconflict_exam primary key (conflict_id, exam_id)
  		</plsql>
  		<mysql>
  			create table %SCHEMA%.xconflict_exam (
				conflict_id decimal(20,0) not null,
				exam_id decimal(20,0) not null,
				primary key (conflict_id, exam_id))
		</mysql>
		<sql>
			alter table %SCHEMA%.xconflict_exam
  				add constraint fk_xconflict_ex_conf foreign key (conflict_id)
  				references %SCHEMA%.xconflict (uniqueid) on delete cascade
  		</sql>
  		<sql>
  			alter table %SCHEMA%.xconflict_exam
  				add constraint fk_xconflict_ex_exam  foreign key (exam_id)
  				references %SCHEMA%.exam (uniqueid) on delete cascade
  		</sql>
  		<plsql>
  			create table %SCHEMA%.xconflict_student (
  				conflict_id number(20,0) constraint nn_xconflict_st_conf  not null,
				student_id number(20,0) constraint nn_xconflict_st_student  not null)
		</plsql>
		<plsql>
			alter table %SCHEMA%.xconflict_student
  			add constraint pk_xconflict_student primary key (conflict_id, student_id)
  		</plsql>
  		<mysql>
  			create table %SCHEMA%.xconflict_student (
  				conflict_id decimal(20,0) not null,
				student_id decimal(20,0) not null,
				primary key (conflict_id, student_id)
			)
  		</mysql>
  		<sql>
  			alter table %SCHEMA%.xconflict_student
  			add constraint fk_xconflict_st_conf foreign key (conflict_id)
  			references %SCHEMA%.xconflict (uniqueid) on delete cascade
  		</sql>
  		<sql>
  			alter table %SCHEMA%.xconflict_student
  			add constraint fk_xconflict_st_student foreign key (student_id)
  			references %SCHEMA%.student (uniqueid) on delete cascade
  		</sql>
  		<plsql>
  			create index %SCHEMA%.idx_xconflict_exam on %SCHEMA%.xconflict_exam(exam_id)
  		</plsql>
  		<mysql>
  			create index idx_xconflict_exam on %SCHEMA%.xconflict_exam(exam_id)
  		</mysql>
	</update>
	<update version="16" date="28-Feb-2008" comment="Exam instructor conflicts">
		<plsql>
			create table %SCHEMA%.xconflict_instructor (
				conflict_id number(20,0) constraint nn_xconflict_in_conf  not null,
				instructor_id number(20,0) constraint nn_xconflict_in_student  not null
			)
		</plsql>
		<plsql>
			alter table %SCHEMA%.xconflict_instructor
  			add constraint pk_xconflict_instructor primary key (conflict_id, instructor_id)
  		</plsql>
  		<mysql>
  			create table %SCHEMA%.xconflict_instructor (
				conflict_id decimal(20,0) not null,
				instructor_id decimal(20,0) not null,
				primary key(conflict_id, instructor_id)
			)
  		</mysql>
  		<sql>
			alter table %SCHEMA%.xconflict_instructor
  			add constraint fk_xconflict_in_conf foreign key (conflict_id)
  			references %SCHEMA%.xconflict (uniqueid) on delete cascade
  		</sql>
  		<sql>
  			alter table %SCHEMA%.xconflict_instructor
  			add constraint fk_xconflict_in_instructor foreign key (instructor_id)
  			references %SCHEMA%.departmental_instructor (uniqueid) on delete cascade
  		</sql>
  		<plsql>
  			alter table %SCHEMA%.exam add assigned_pref varchar2(100)
  		</plsql>
  		<mysql>
  			alter table %SCHEMA%.exam add assigned_pref varchar(100)
  		</mysql>
	</update>
	<update version="17" date="3-Mar-2008" comment="Evening exams">
		<plsql>
			alter table exam add exam_type number(10,0) default 0
		</plsql>
		<plsql>
			alter table exam_period add exam_type number(10,0) default 0
		</plsql>
		<mysql>
			alter table exam add exam_type bigint(10) default 0
		</mysql>
		<mysql>
		alter table exam_period add exam_type bigint(10) default 0
		</mysql>
	</update>
</dbupdate>